<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>秋招嘎嘎乱杀 | Jun</title><meta name="author" content="🌶辣椒炒饭"><meta name="copyright" content="🌶辣椒炒饭"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="# Java 并发：如何保证线程之间的变量同步？ 描述：就是变量 A 如果在线程 A 中做了修改，那么在线程 B 中应该获取到的是修改后的变量值。 # Java 并发：在 Java 中守护线程和本地线程区别？ Java 中的线程分为两种：守护线程和用户线程 其实任何线程都可以设置为守护线程和用户线程。 通过方法 Thread.setDaemon (true) 设置 区别： 执行权不同。在 Java">
<meta property="og:type" content="article">
<meta property="og:title" content="秋招嘎嘎乱杀">
<meta property="og:url" content="https://github.com/hacker-jun/666.github.io/2023/09/05/%E7%A7%8B%E6%8B%9B%E5%98%8E%E5%98%8E%E4%B9%B1%E6%9D%80/index.html">
<meta property="og:site_name" content="Jun">
<meta property="og:description" content="# Java 并发：如何保证线程之间的变量同步？ 描述：就是变量 A 如果在线程 A 中做了修改，那么在线程 B 中应该获取到的是修改后的变量值。 # Java 并发：在 Java 中守护线程和本地线程区别？ Java 中的线程分为两种：守护线程和用户线程 其实任何线程都可以设置为守护线程和用户线程。 通过方法 Thread.setDaemon (true) 设置 区别： 执行权不同。在 Java">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/hacker-jun/666.github.io/img/f4aa9cd4d88b8eda7d695ba4f1c6cbb0_1.jpg">
<meta property="article:published_time" content="2023-09-05T12:24:19.000Z">
<meta property="article:modified_time" content="2023-09-06T12:34:42.918Z">
<meta property="article:author" content="🌶辣椒炒饭">
<meta property="article:tag" content="Java Python Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/hacker-jun/666.github.io/img/f4aa9cd4d88b8eda7d695ba4f1c6cbb0_1.jpg"><link rel="shortcut icon" href="/666.github.io/img/web.png"><link rel="canonical" href="https://github.com/hacker-jun/666.github.io/2023/09/05/%E7%A7%8B%E6%8B%9B%E5%98%8E%E5%98%8E%E4%B9%B1%E6%9D%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/666.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/666.github.io/%E9%9B%A8%E7%9C%A0%E4%B9%8B%E9%9F%B3" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/666.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '秋招嘎嘎乱杀',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-06 20:34:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/666.github.io/img/f4aa9cd4d88b8eda7d695ba4f1c6cbb0_1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/666.github.io/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/666.github.io/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/666.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/666.github.io/"><i class="fa-fw fas fa-mosque"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/666.github.io/archives/"><i class="fa-fw fas fa-pencil-alt"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/666.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/666.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/666.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/666.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/666.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/666.github.io/img/wallhaven-28rvdg.jpg')"><nav id="nav"><span id="blog-info"><a href="/666.github.io/" title="Jun"><span class="site-name">Jun</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/666.github.io/"><i class="fa-fw fas fa-mosque"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/666.github.io/archives/"><i class="fa-fw fas fa-pencil-alt"></i><span> 档案</span></a></div><div class="menus_item"><a class="site-page" href="/666.github.io/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/666.github.io/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div><div class="menus_item"><a class="site-page" href="/666.github.io/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/666.github.io/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/666.github.io/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">秋招嘎嘎乱杀</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-05T12:24:19.000Z" title="发表于 2023-09-05 20:24:19">2023-09-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-06T12:34:42.918Z" title="更新于 2023-09-06 20:34:42">2023-09-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="秋招嘎嘎乱杀"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="java并发如何保证线程之间的变量同步"><a class="markdownIt-Anchor" href="#java并发如何保证线程之间的变量同步">#</a> Java 并发：如何保证线程之间的变量同步？</h1>
<p>描述：就是变量 A 如果在线程 A 中做了修改，那么在线程 B</p>
<p>中应该获取到的是修改后的变量值。</p>
<h2 id="java并发在java中守护线程和本地线程区别"><a class="markdownIt-Anchor" href="#java并发在java中守护线程和本地线程区别">#</a> Java 并发：在 Java 中守护线程和本地线程区别？</h2>
<p>Java 中的线程分为两种：守护线程和用户线程</p>
<p>其实任何线程都可以设置为守护线程和用户线程。</p>
<p>通过方法 Thread.setDaemon (true) 设置</p>
<p><strong>区别：</strong></p>
<p>执行权不同。在 Java 中，本地线程指的是使用线程库创建的线程，由操作系统管理和调度。本地线程可以与其他线程并发执行，因此其执行顺序是不可预测的。相比之下，守护线程是由 Java 虚拟机管理和调度的轻量级线程，其执行次数通常较少，而其执行顺序通常是固定的。</p>
<p>守护线程不管主程序是否运行，只要虚拟机还在就会一直运行。</p>
<h2 id="spring通知"><a class="markdownIt-Anchor" href="#spring通知">#</a> Spring 通知</h2>
<p>Spring 切面的五种类型的通知</p>
<ul>
<li>before，前置通知，就是在一个方法被执行前被调用</li>
<li>after，顾名思义，在方法执行之后被调用的通知，无论方法执行是否会成功</li>
<li>after-returning：只有方法成功被执行后才会有的通知</li>
<li>after-throwing: 在方法出现异常后被执行的通知</li>
<li>around：在方法执行之前和之后被调用的通知</li>
</ul>
<h2 id="微服务架构"><a class="markdownIt-Anchor" href="#微服务架构">#</a> 微服务架构</h2>
<h2 id="volatile关键字"><a class="markdownIt-Anchor" href="#volatile关键字">#</a> volatile 关键字</h2>
<p><code>volatile</code>  是 Java 中的一个关键字，用于修饰变量。当一个变量被 <code>volatile</code>  修饰时，它具有以下特性：</p>
<ol>
<li>可见性： <code>volatile</code>  变量的修改会立即对其他线程可见。当一个线程修改了一个 <code>volatile</code>  变量的值时，它会立即刷新到主内存中，而其他线程在读取该变量时会从主内存中获取最新的值。</li>
<li>有序性： <code>volatile</code>  变量具有禁止指令重排序的特性。在多线程环境下，指令重排序可能会影响程序的正确性，但 <code>volatile</code>  变量的读写操作会保持有序，不会发生乱序执行。</li>
</ol>
<p>需要注意的是， <code>volatile</code>  只能保证单个变量的可见性和有序性，无法保证一组操作的原子性。如果需要保证多个操作的原子性，可以考虑使用 <code>synchronized</code>  关键字或 <code>java.util.concurrent.atomic</code>  包提供的原子类。</p>
<p>下面是一个示例代码，展示如何使用 <code>volatile</code>  修饰变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(<span class="type">boolean</span> value)</span> &#123;</span><br><span class="line">        flag = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">            <span class="comment">// 循环等待，直到flag为true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行其他操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中， <code>flag</code>  被声明为 <code>volatile</code> ，保证了在 <code>doSomething</code>  方法中对 <code>flag</code>  的修改对其他线程可见。当 <code>setFlag</code>  方法将 <code>flag</code>  设置为 <code>true</code>  时， <code>doSomething</code>  方法中的循环会退出，从而执行后续操作。</p>
<p>需要注意的是，虽然 <code>volatile</code>  可以满足大部分的可见性和有序性需求，但并不适用于所有的场景。在某些情况下，可能需要使用更强大的同步手段来确保线程安全性，如使用 <code>synchronized</code>  关键字或锁机制。</p>
<h2 id="synchronized修饰变量"><a class="markdownIt-Anchor" href="#synchronized修饰变量">#</a> synchronized 修饰变量</h2>
<p>在 Java 中， <code>synchronized</code>  关键字不能直接修饰变量。 <code>synchronized</code>  关键字可以用于实现线程之间的同步，它可以修饰代码块、方法和静态方法，用于确保在执行同步代码时只有一个线程能够访问共享资源。</p>
<p>如果你想要同步访问或修改某个变量，一种常见的做法是将该变量封装在一个对象中，然后使用 <code>Synchronized</code>  关键字来同步访问该对象的方法或代码块。</p>
<p>下面是一个示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 访问或修改共享变量</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 访问共享变量</span></span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们将共享变量 <code>count</code>  封装在一个对象 <code>lock</code>  中，并使用 <code>synchronized</code>  关键字来同步访问和修改 <code>count</code> 。通过构造一个同步块（synchronized block）并传入 <code>lock</code>  对象作为锁对象，确保了对 <code>count</code>  的操作是同步的。只有一个线程能够同时执行被 <code>synchronized</code>  修饰的代码块。</p>
<p>需要注意的是，在同步访问和修改共享变量时，必须使用同一个锁对象。否则，不同的锁对象将无法实现线程之间的同步。</p>
<p>另外，Java 5 引入了 <code>java.util.concurrent.atomic</code>  包，它提供了一组原子类（Atomic Classes），可以用来对单个变量进行原子操作，避免了显式的锁和同步块。如果只需要对单个变量进行原子操作，可以考虑使用这些原子类。</p>
<h2 id="多线程的上下文切换"><a class="markdownIt-Anchor" href="#多线程的上下文切换">#</a> 多线程的上下文切换</h2>
<p>在一组计算机的 cpu 中，多线程会共同使用，即共享。当线程数大于给程序分配的 CPU 数量时，就需要轮转使用 CPU，不同的线程切换使用 CPU 时发生的切换数据就是上下文切换。</p>
<h2 id="java中wait和sleep方法的不同"><a class="markdownIt-Anchor" href="#java中wait和sleep方法的不同">#</a> Java 中 wait 和 sleep 方法的不同</h2>
<p>最大的区别是在等待时 wait 会释放锁，但是 sleep 会一直持有锁。前者用来线程交互，后者用来暂停执行。</p>
<p>线程的六种状态：</p>
<p>首先是<strong>初始态</strong>：NEW</p>
<p>创建一个 Thread 对象，但还未调用 start（）启动线程时，该线程就处于初始态。</p>
<p><strong>运行态</strong>：RUNNABLE</p>
<p>Java 中的运行态包括<strong>就绪态</strong>和<strong>运行态</strong></p>
<p>就绪态： 该状态下的线程已经获得了执行所需要的资源，就差 CPU 的执行权获得就能运行。（所有就绪态的线程存放在就绪队列中）</p>
<p>运行态： 就绪态获得了 CPU 的执行权，正在执行的线程，由于一个 CPU 同一时刻只能执行一条线程，所以每个 CPU 每个时刻只能有一条运行态的线程。</p>
<p><strong>阻塞态</strong></p>
<p>当一条正在执行的线程请求某一资源失败时，就会进入阻塞态。而在 java 中，阻塞态专指请求锁失败时进入的状态。由一个阻塞队列存放所有阻塞态的线程。处于阻塞态的线程会不断请求它所需要的资源。一旦请求成功。就会进入就绪队列。然后等待执行。</p>
<p>这里讲一下资源有哪些：锁、IO 、Socket 等</p>
<p><strong>等待态</strong></p>
<p>当前线程中调用 wait、join、park 函数时，当前的线程就会进入等待态。有就绪队列，同时也有等待队列。这些等待态的线程就会存放在一个等待队列中。线程处于等待态表示它有需要等待其他的线程指示或者输出结果才能继续运行。（进入等待态的线程会释放 CPU 的执行权。并且释放资源。）</p>
<p><strong>超时等待态</strong></p>
<p>当运行中的线程调用 sleep（time)、wait、join、parkNanos、parkUntil 时。就会进入该状态。它和等待态一样，并不是因为请求不到资源，而是主动进入，并</p>
<p>且进入后需要其他线程唤醒；进入 该状态后释放 CPU 执行权</p>
<p>和 占有的资源。与等待态的区别：到了超时时间后自动进入阻塞队列，开始竞争锁。</p>
<p><strong>终止态</strong></p>
<p>线程执行结束后的状态。</p>
<p>注意：</p>
<p>wait () 方法会释放 CPU 执行权，还有占有的锁。</p>
<p>sleep (long) 方法仅释放 CPU 使用权，锁仍然占用。线程被放入超时等待队列中，与 yied 相比，它会使线程较长时间得不到运行。</p>
<p>yield () 方法仅释放 CPU 执行权，锁仍然被占用。线程就会被放入就绪队列。会在短时间内再次执行。</p>
<p>wait 和 notify 必须配套使用，即必须使用同意一把锁调用。</p>
<p>wait 和 notify 必须放在一个同步块中调用 wait 和 notify 的对象必须是他们所处同步块的锁对象。</p>
<h2 id="线程池是什么框架建立的"><a class="markdownIt-Anchor" href="#线程池是什么框架建立的">#</a> 线程池是什么框架建立的</h2>
<p>从 JDK1.5 开始，JavaAPI 提供了 Executor 框架让你可以创建不同的线程池。</p>
<h2 id="如何检测一个线程是否拥有锁"><a class="markdownIt-Anchor" href="#如何检测一个线程是否拥有锁">#</a> 如何检测一个线程是否拥有锁？</h2>
<p>在 Java.lang.Thread 中有一个方法叫做 holdLock ()，它返回 true 如果当且仅当当前线程拥有某个具体的对象锁</p>
<h2 id="你对线程优先级的理解是什么"><a class="markdownIt-Anchor" href="#你对线程优先级的理解是什么">#</a> 你对线程优先级的理解是什么？</h2>
<p>每个线程都有优先级，一般来说，高优先级的线程在运行时会有优先权。这依赖于线程调度的实现。</p>
<p>线程优先级是一个 int 变量（1-10），1 代表最低优先级，10 代表最高优先级。</p>
<p>注：一般情况下，不需要设置线程优先级。</p>
<h2 id="并发编程的三要素"><a class="markdownIt-Anchor" href="#并发编程的三要素">#</a> 并发编程的三要素</h2>
<ol>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ol>
<h2 id="四种线程池的创建"><a class="markdownIt-Anchor" href="#四种线程池的创建">#</a> 四种线程池的创建</h2>
<ol>
<li>newCachedThreadPool 创建一个可缓存的线程池</li>
<li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数</li>
<li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行</li>
<li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务</li>
</ol>
<h2 id="线程池的优点"><a class="markdownIt-Anchor" href="#线程池的优点">#</a> 线程池的优点</h2>
<ol>
<li>重用存在的线程，减少对象创建销毁的开销</li>
<li>可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞</li>
<li>提供定时执行、定期执行、单线程、并发书控制等功能</li>
</ol>
<h2 id="synchronized的作用"><a class="markdownIt-Anchor" href="#synchronized的作用">#</a> synchronized 的作用</h2>
<p>synchronized 关键字是用来控制线程同步的，</p>
<h2 id="volatile"><a class="markdownIt-Anchor" href="#volatile">#</a> volatile</h2>
<p>Java 提供 volatile 关键字来保证可见性</p>
<p>当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存中，当有其他线程需要读取时，它会去内存中读取新的值</p>
<p>在实际应用中，volatile 的一个重要作用就是和 CAS 共同作用，保证原子性</p>
<h2 id="cas"><a class="markdownIt-Anchor" href="#cas">#</a> CAS</h2>
<p>compare and swap, 就是常说的比较交换</p>
<p>是一种基于锁的操作，且是乐观锁</p>
<h2 id="线程b怎么知道线程a修改了变量"><a class="markdownIt-Anchor" href="#线程b怎么知道线程a修改了变量">#</a> 线程 B 怎么知道线程 A 修改了变量</h2>
<ol>
<li>volatile 修饰变量</li>
<li>synchronized 修饰变量的方法</li>
<li>wait/notify</li>
<li>while 轮询</li>
</ol>
<h2 id="synchronizedmap和concueeenthashmap的区别"><a class="markdownIt-Anchor" href="#synchronizedmap和concueeenthashmap的区别">#</a> SynchronizedMap 和 ConcueeentHashMap 的区别</h2>
<p>SynchronizedMap 每次只允许一个线程来访问 Map</p>
<p>ConcurrentHashMap 使用分段锁保证多线程下的性能</p>
<p>所谓分段锁就是一次锁一个桶，ConcurrentHashMap 默认把 hash 表分为 16 个桶，然后使用 get,put,remove 等常用操作只锁住当前的桶，</p>
<p>桶的解释：</p>
<h2 id="怎样检测一个线程是否拥有锁"><a class="markdownIt-Anchor" href="#怎样检测一个线程是否拥有锁">#</a> 怎样检测一个线程是否拥有锁</h2>
<p>holdsLock () 方法，</p>
<h2 id="java线程数过多会造成什么异常"><a class="markdownIt-Anchor" href="#java线程数过多会造成什么异常">#</a> Java 线程数过多会造成什么异常？</h2>
<p>1、 线程的生命周期开销非常高</p>
<p>2、 资源消耗高</p>
<p>3、 降低虚拟机的稳定性</p>
<h2 id="jvm的启动参数"><a class="markdownIt-Anchor" href="#jvm的启动参数">#</a> JVM 的启动参数</h2>
<hr>
<h1 id="mybatis-和的区别"><a class="markdownIt-Anchor" href="#mybatis-和的区别">#</a> Mybatis: #{} 和 ${} 的区别？</h1>
<p>说明：#{} 是预编译处理，${} 是字符串替换</p>
<p>Mybatis 在处理 #{} 时，会将 sql 中的 #{} 替换为？号，调用 PreparedStatement 的 set 方法来赋值。</p>
<h2 id="说明preparedstatement"><a class="markdownIt-Anchor" href="#说明preparedstatement">#</a> 说明：PreparedStatement</h2>
<p>PreparedStatement 是 Java JDBC API 中的一个接口，用于预编译 SQL 语句并将参数传递给数据库。与 Statement 相比，PreparedStatement 具有以下优点：</p>
<ol>
<li>预编译：PreparedStatement 对象在执行前会将 SQL 语句发送到数据库进行预编译，这样可以提高 SQL 执行效率。</li>
<li>安全性：通过占位符（?）来表示参数，可以防止 SQL 注入攻击，同时也减少了手动拼接 SQL 语句的错误风险。</li>
<li>可维护性：使用 PreparedStatement 可以使代码结构更清晰，易于维护和修改。</li>
</ol>
<p>使用 PreparedStatement 需要以下步骤：</p>
<ol>
<li>创建 PreparedStatement 对象：通过 Connection 对象的 prepareStatement 方法创建 PreparedStatement 对象，并传入带有占位符的 SQL 语句。</li>
<li>设置参数：使用 PreparedStatement 对象的 setXXX 方法（如 setString、setInt 等）设置 SQL 语句中的占位符对应的参数值。</li>
<li>执行 SQL 语句：使用 PreparedStatement 对象的 execute、executeQuery 或 executeUpdate 方法执行 SQL 语句。</li>
</ol>
<p>下面是一个简单的示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 假设已经建立了合适的数据库连接 Connection conn</span><br><span class="line"></span><br><span class="line">// 创建 PreparedStatement 对象</span><br><span class="line">String sql = &quot;SELECT * FROM users WHERE age &gt; ?&quot;;</span><br><span class="line">PreparedStatement pstmt = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">// 设置参数</span><br><span class="line">int ageThreshold = 18;</span><br><span class="line">pstmt.setInt(1, ageThreshold);</span><br><span class="line"></span><br><span class="line">// 执行查询</span><br><span class="line">ResultSet rs = pstmt.executeQuery();</span><br><span class="line"></span><br><span class="line">// 处理查询结果</span><br><span class="line">while (rs.next()) &#123;</span><br><span class="line">    String name = rs.getString(&quot;name&quot;);</span><br><span class="line">    int age = rs.getInt(&quot;age&quot;);</span><br><span class="line">    // 处理每一行数据</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关闭资源</span><br><span class="line">rs.close();</span><br><span class="line">pstmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure>
<p>使用 PreparedStatement 可以方便地执行带有参数的 SQL 语句，提高了代码的效率和安全性。</p>
<p>Mybatis 在处理<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow></mrow><mtext>时，会把</mtext></mrow><annotation encoding="application/x-tex">{}时，会把</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"></span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">把</span></span></span></span> {} 替换成变量的值。</p>
<p>使用替换为？的可以有效防止 SQL 注入。</p>
<h2 id="锁的类别"><a class="markdownIt-Anchor" href="#锁的类别">#</a> 锁的类别</h2>
<p>1、 表级锁：开销比较小，不会出现死锁，并发度比较低</p>
<p>2、 行级锁：开销比较大，会出现死锁，并发度比较高</p>
<p>3、 页面锁：开销一般，会出现死锁，并发度一般</p>
<h2 id="myisam和innodb的区别"><a class="markdownIt-Anchor" href="#myisam和innodb的区别">#</a> MyISAM 和 InnoDB 的区别</h2>
<p>MyISAM：</p>
<p>不支持事务，支持表级锁（就是每次操作都会对整个表上锁）</p>
<p>InnoDB:</p>
<p>支持 ACID 的事务，支持事物的四种隔离级别</p>
<p>支持行级锁以及外键的约束，因此可以支持写并发</p>
<h2 id="char-和-varchar的区别"><a class="markdownIt-Anchor" href="#char-和-varchar的区别">#</a> char 和 varchar 的区别</h2>
<p>1、 char 和 varchar 存储和检索的方式不同</p>
<p>2、 char 的长度固定为声明时的长度，范围是 1 到 255。</p>
<h2 id="防止sql注入的方式"><a class="markdownIt-Anchor" href="#防止sql注入的方式">#</a> 防止 SQL 注入的方式</h2>
<p>产生 SQL 注入的原因：</p>
<p>不注意规范的书写 sql 语句和对特殊字符进行过滤，导致客户端可以通过局部变量 POST 和 GET 提交一些 sql 语句并且正常执行</p>
<p>方式：</p>
<p>1、 开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置</p>
<p>2、 执行 sql 语句时使用 addslashes 进行 sql 语句转换</p>
<p>3、 Sql 语句书写尽量不要省略双引号和单引号</p>
<p>4、 过滤掉 sql 语句中的一些关键字，update、insert、delete、select</p>
<p>​	提高数据库表和字段的命名技巧，对于一些重要的字段根据程序的特点命名，取不易被猜到的名字。</p>
<h2 id="sql优化的方式"><a class="markdownIt-Anchor" href="#sql优化的方式">#</a> SQL 优化的方式</h2>
<p>1、 在 Where 中，表之间的连接需要写在其它 where 条件之前，</p>
<p>2、 用 exists 替换 in、用 not exists 替换 not in</p>
<p>3、 避免在建立了索引的列上面运算</p>
<p>4、 不要在建立了索引的列上面使用 is null 和 is not null</p>
<h2 id="mybatis的优势"><a class="markdownIt-Anchor" href="#mybatis的优势">#</a> Mybatis 的优势</h2>
<p>1、 基于 SQL 语句编写，相当灵活，不会对应用程序或者数据库现有的设计造成影响，SQL 写在 XML 中，解除了 SQL 与代码的耦合，可以更加方便的进行服务外部配置，并且支持动态 SQL.</p>
<p>2、 相比于 JDBC, 消除了 JDBC 的大量代码，并且不需要手动连接。</p>
<p>（注：不需要手动连接的原因，在使用 JDBC 进行数据库连接操作时，需要手动地建立和关闭连接，整个操作过程涉及数据库驱动，创建 Connection 对象，设置连接参数，处理 SQLException 等操作。</p>
<p>而 Mybatis 简化了整个过程，它提供了一个 SqlSessionFactory 对象。我们通过使用这个对象来获取 SqlSession。然后就可以执行 SQL 对象了。SqlSessionFactory 和 SqlSession 都会自动管理数据库连接的创建和关闭，我们不需要手动处理这些细节。</p>
<p>具体来说，MyBatis 在内部使用了连接池（Connection Pool）来管理数据库连接。当我们需要执行 SQL 语句时，MyBatis 会从连接池中获取一个可用的连接，执行完毕后再把连接放回连接池。如果连接池中没有可用的连接，MyBatis 会自动创建新的连接。当连接不再使用时，MyBatis 会自动关闭连接，释放资源。</p>
<p>所以，&quot;不需要手动连接&quot; 意味着我们不需要手动创建和关闭数据库连接，MyBatis 会自动处理这些操作，使得代码更加简洁和易于管理。)</p>
<p>3、 与各种数据库兼容</p>
<p>4、 能够与 Spring 很好的集成</p>
<p>5、 提供映射标签，支持对象与数据库地 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</p>
<p>注：</p>
<p>&quot;映射标签&quot; 和 &quot;对象关系映射标签&quot; 是 MyBatis 中的重要概念。</p>
<ol>
<li><strong>映射标签</strong>：MyBatis 的映射标签是用于定义 SQL 语句与 Java 对象之间的映射关系的标签。例如， <code>&lt;select&gt;</code>  标签用于映射数据库查询操作， <code>&lt;insert&gt;</code>  标签用于映射数据库插入操作， <code>&lt;update&gt;</code>  标签用于映射数据库更新操作， <code>&lt;delete&gt;</code>  标签用于映射数据库删除操作。通过这些标签，开发者可以将数据库操作与 Java 对象进行关联，从而简化数据库操作的开发过程。</li>
<li><strong>对象关系映射标签</strong>：对象关系映射（ORM）是一种设计模式，它使用对象来封装关系数据库中的数据，以提供更高级别的抽象。MyBatis 的对象关系映射标签可以帮助开发者实现这种抽象。例如， <code>&lt;resultMap&gt;</code>  标签可以定义 Java 对象与数据库表之间的映射关系， <code>&lt;association&gt;</code>  标签可以定义 Java 对象与数据库表之间的关联关系， <code>&lt;collection&gt;</code>  标签可以定义 Java 对象集合与数据库表之间的映射关系。通过这些标签，开发者可以轻松地实现对象与数据库的 ORM 字段关系映射，以及对象关系组件的维护。</li>
</ol>
<p>通过这些标签，MyBatis 提供了强大的映射和抽象功能，使得开发者可以更加专注于业务逻辑的开发，而不用关心底层的数据库操作细节。</p>
<hr>
<h1 id="javase封装继承多态"><a class="markdownIt-Anchor" href="#javase封装继承多态">#</a> JavaSE，封装，继承，多态</h1>
<p>不多说了，百度吧</p>
<h2 id="四个访问修饰符publicprivateprotected不写default"><a class="markdownIt-Anchor" href="#四个访问修饰符publicprivateprotected不写default">#</a> 四个访问修饰符，public，private，protected, 不写（default）</h2>
<h2 id="内存中的栈stack堆heap方法区method-area"><a class="markdownIt-Anchor" href="#内存中的栈stack堆heap方法区method-area">#</a> 内存中的栈（stack), 堆（heap), 方法区（method area).</h2>
<p>在计算机科学领域，“stack”（栈）、“heap”（堆）和 &quot;method area&quot;（方法区）是三个常用的术语，用于描述内存管理的不同方面。</p>
<ol>
<li>栈（Stack）：<br>
栈是一种线性数据结构，用于存储函数调用和局部变量等信息。栈采用 &quot;后进先出&quot;（LIFO）的方式进行操作，即最后进入栈的数据最先被取出。栈内存的大小是固定的，在程序执行时会自动分配和释放内存。每当一个函数被调用时，栈都会为该函数分配一段局部变量的内存空间，随着函数执行的结束，这些内存空间也会被释放。栈的操作速度非常快，因此适用于存储较小的数据块和需要快速分配和释放内存的情况。</li>
<li>堆（Heap）：<br>
堆是用于动态分配内存的一种存储区域，它的大小通常比栈大得多。相对于栈来说，堆是一种更为灵活的内存分配方式，可以按需分配和释放内存。在堆中分配的内存块可以由多个部分组成，称为 &quot;对象&quot; 或 &quot;数据结构&quot;。堆内存的分配和释放需要显式的指令，一般由程序员手动管理或通过垃圾回收机制自动回收不再使用的对象。堆适用于需要在不同函数之间共享数据或存储较大数据结构的情况。</li>
<li>方法区（Method Area）：<br>
方法区是一种特殊的堆区域，主要用于存储类的相关信息，如类的结构、静态变量、常量池、方法代码等。方法区在程序启动时被加载，其大小也是固定的，并且与堆区相互独立。方法区的数据由多个线程共享，因此需要进行并发访问控制。在 Java 虚拟机中，方法区也被称为 &quot;永久代&quot;（Permanent Generation），但在最新版本的 JVM 中，它已被 &quot;元空间&quot;（Metaspace）所取代。</li>
</ol>
<p>综上所述，栈用于存储<strong>函数调用</strong>和<strong>局部变量</strong>，堆用于<strong>动态分配内存</strong>和<strong>存储较大数据结构</strong>，方法区用于存储类的相关信息。这三个内存区域在计算机程序执行过程中起着不同的作用和管理方式。</p>
<h2 id="数组和string的一些差异"><a class="markdownIt-Anchor" href="#数组和string的一些差异">#</a> 数组和 String 的一些差异</h2>
<p>数组没有 length () 方法，但是有 length 的属性，String 有 length () 方法，</p>
<h2 id="构造器constructor与重写override"><a class="markdownIt-Anchor" href="#构造器constructor与重写override">#</a> 构造器（constructor）与重写（override)</h2>
<p>构造器不能被继承，于是也不能被重写，但是可以被重载</p>
<h2 id="两个对象值相同即xequalsy-true但有不同的hash-code-是否正确"><a class="markdownIt-Anchor" href="#两个对象值相同即xequalsy-true但有不同的hash-code-是否正确">#</a> 两个对象值相同，即（x.equals (y) == true), 但有不同的 hash code。是否正确？</h2>
<p>是对的，这是可能发生的情况。根据 Java 对象的规范，如果两个对象通过 <code>equals()</code>  方法比较返回 <code>true</code> ，则它们被认为是相等的。但是，即使两个对象的值相同，它们的哈希码（hash code）不一定相同。</p>
<p>Java 中的哈希码是通过 <code>hashCode()</code>  方法生成的一个整数，用于在哈希表等数据结构中快速查找对象。根据规范，如果两个对象通过 <code>equals()</code>  方法比较返回 <code>true</code> ，那么它们的哈希码通常应该相等。但这并不是强制性的要求，因为两个不同的对象可以具有相同的值但不同的哈希码。</p>
<p>当两个对象的哈希码不相同时，它们可能被放置在哈希表的不同桶中，导致无法正确查找某些操作。因此，在重写 <code>equals()</code>  方法时，也应该相应地重写 <code>hashCode()</code>  方法，以确保相等的对象具有相等的哈希码。</p>
<p>简而言之，两个对象的值相同但哈希码不同是合法的，但在实际使用中可能会导致一些问题，因此建议在重写 <code>equals()</code>  方法时同时重写 <code>hashCode()</code>  方法。</p>
<h2 id="类加载器的类别与作用"><a class="markdownIt-Anchor" href="#类加载器的类别与作用">#</a> 类加载器的类别与作用</h2>
<p>类加载器（Class Loader）是 Java 虚拟机（JVM）的一部分，负责将字节码文件加载到内存中，并转换为可执行的 Java 类。在 Java 中，类加载器分为以下几个类别：</p>
<ol>
<li>启动类加载器（Bootstrap Class Loader）：<br>
启动类加载器是 JVM 的一部分，用于加载核心 Java 类库（如 rt.jar 等）。它是 JVM 自身的一部分，通常由本地代码实现，不是 Java 类。启动类加载器是在 JVM 启动时被创建的，它负责加载 JVM 运行所需的基础类。</li>
<li>扩展类加载器（Extension Class Loader）：<br>
扩展类加载器用于加载 JRE 扩展目录（jre/lib/ext）中的类库。它是由 Java 类 <code>sun.misc.Launcher$ExtClassLoader</code>  实现的，它是启动类加载器的子类。扩展类加载器在 JVM 启动时创建，并在需要时动态加载类库。</li>
<li>应用程序类加载器（Application Class Loader）：<br>
应用程序类加载器是用于加载应用程序类的加载器。它是由 Java 类 <code>sun.misc.Launcher$AppClassLoader</code>  实现的，它是扩展类加载器的子类。应用程序类加载器是在 JVM 启动时创建的，它从系统类路径（classpath）中加载类。大多数应用程序的类都由应用程序类加载器加载。</li>
</ol>
<p>除了这些内置的类加载器，Java 还提供了一些自定义的类加载器，用于满足特定的需求，例如：</p>
<ul>
<li>自定义类加载器（Custom Class Loader）：<br>
开发人员可以通过继承 <code>java.lang.ClassLoader</code>  类创建自定义的类加载器。自定义类加载器可以根据自己的需求从非标准位置加载类，实现类的动态加载等功能。</li>
</ul>
<p>不同的类加载器有不同的作用，它们协同工作来加载和管理 Java 类。类加载器的主要目标是按需加载类，以避免不必要的资源消耗和提高应用程序的性能。它们还提供了类隔离和命名空间的概念，允许在同一个 JVM 中加载不同版本或来源的类。</p>
<h2 id="实现对象的克隆"><a class="markdownIt-Anchor" href="#实现对象的克隆">#</a> 实现对象的克隆</h2>
<p>实现思路是：新建一个对象类，并在另一个 main 方法中使用 Cloneable 克隆它</p>
<p>如何创建一个对象类，并在另一个 <code>main</code>  方法中使用 <code>Cloneable</code>  接口进行克隆？</p>
<p>首先，让我们创建一个可克隆的对象类 <code>MyObject</code> ，它需要实现 <code>Cloneable</code>  接口并重写 <code>clone()</code>  方法。这样才能在后续使用 <code>clone()</code>  进行对象克隆。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyObject</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们已经创建了一个可克隆的对象类 <code>MyObject</code> ，接下来让我们在另一个 <code>main</code>  方法中使用它进行克隆。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyObject</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyObject</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MyObject</span> <span class="variable">obj2</span> <span class="operator">=</span> (MyObject) obj1.clone();</span><br><span class="line">            System.out.println(<span class="string">&quot;obj1 value: &quot;</span> + obj1.getValue());</span><br><span class="line">            System.out.println(<span class="string">&quot;obj2 value: &quot;</span> + obj2.getValue());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，我们首先创建了一个 <code>MyObject</code>  对象 <code>obj1</code> ，并设置其值为 10。然后通过调用 <code>clone()</code>  方法，将 <code>obj1</code>  克隆成 <code>obj2</code> 。最后，分别打印了 <code>obj1</code>  和 <code>obj2</code>  的值。</p>
<p>当我们运行 <code>main</code>  方法时，将会输出以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1 value: 10</span><br><span class="line">obj2 value: 10</span><br></pre></td></tr></table></figure>
<p>这表明对象 <code>obj1</code>  成功克隆为对象 <code>obj2</code> ，并且它们的值相同。</p>
<h2 id="查看jvm参数并了解其含义"><a class="markdownIt-Anchor" href="#查看jvm参数并了解其含义">#</a> 查看 JVM 参数并了解其含义</h2>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal</span><br></pre></td></tr></table></figure>
<h2 id="关于静态成员变量构造器父类与子类同存的代码题"><a class="markdownIt-Anchor" href="#关于静态成员变量构造器父类与子类同存的代码题">#</a> 关于静态成员变量，构造器，父类与子类同存的代码题</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ObjectTemp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: jun</span></span><br><span class="line"><span class="comment"> * @Date:2023/8/24 15:46</span></span><br><span class="line"><span class="comment"> * @概述：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Atemp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">B</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();<span class="comment">//不管是A ab = new B()</span></span><br><span class="line">        ab = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果是：1a2b2b.</p>
<p>在创建对象时构造器的调用顺序是：先初始化静态成员，然后再调用父类构造器，再初始化非静态成员变量，最后调用自身构造器。</p>
<h2 id="cdn是啥"><a class="markdownIt-Anchor" href="#cdn是啥">#</a> CDN 是啥？</h2>
<p>Content Delivery Network</p>
<p>内容分发网络</p>
<p>核心技术：</p>
<ol>
<li>负载均衡：有多台不同地理位置，不同访问速度的服务器解析来自不同的位置的用户请求，通过对服务器进行实时监测，将各节点流量保存至数据库，对系统中监测到的系统状态产生故障告警，给用户定向至最优的 CDN 节点</li>
<li>内存存储：主要有两个方面，其实站点的源服务器（根服务器）和 Cache 节点中的存储功能，源服务器的客户请求有很大一部分分发给了 CDN 节点，目的如上第一点，同时你需要把大量的数据也给分发出去，但是数量巨大，为了方便存储读取，会根据 CDN 节点的规律去存储内容，现代的物流系统也是一个比较实物现实的服务系统。可以参考物流系统中建立仓库，提前分发包裹给各地仓库，已达到 3 日达的效果甚至次日达的速度。</li>
<li>内容发布：借助索引，缓存，流分裂，组播等技术，将内容由内容源分发到 CDN 边缘的整个缓存过程，内容分发技术主要是 PUSH (主动分发技术）和 PULL (被动分发技术）。PUSH 一般是由供应商或是 CDN 的内容管理人员从站点源服务器或媒体的资源库直接向各个 CDN 节点主动分发的一些热点内容，或是客户指定的内容。PULL 则是客户向节点请求缓存中没有存储的内容时，Cache 从源服务器或是其他 CDN 节点请求获取内容。</li>
</ol>
<h2 id="string-s-new-stringxyz创建了几个字符串对象"><a class="markdownIt-Anchor" href="#string-s-new-stringxyz创建了几个字符串对象">#</a> String s = new String (“xyz”); 创建了几个字符串对象？</h2>
<p>两个，一个是静态区的 “xyz”, 另一个是用 new 创建在堆上的对象。</p>
<h2 id="一道类似的题问法不同"><a class="markdownIt-Anchor" href="#一道类似的题问法不同">#</a> 一道类似的题：问法不同</h2>
<p>String str = new String (“abc”) 到底 new 了几个对象？</p>
<p>分两种情况：</p>
<ol>
<li>new 了一个：如果常量池中已经有了 &quot;abc&quot; 这个字符串，也就是说你在前面已经 new 过一个值为”abc&quot; 的字符串，那么虚拟机就会在堆内存中 new 一个 String 对象，并将常量池中 “abc” 的地址指向你刚刚 new 的 String 对象。</li>
<li>new 了两个：如果常量池中没有 “abc&quot; 这个字符串，那么虚拟机就会在堆内存中 new 出一个 String 对象，并且在常量池中 new 一个 abc 字符串对象。</li>
</ol>
<h2 id="阐述arraylist-vector-linkedlist-的存储性能和特性"><a class="markdownIt-Anchor" href="#阐述arraylist-vector-linkedlist-的存储性能和特性">#</a> 阐述 ArrayList、Vector、LinkedList 的存储性能和特性。</h2>
<p>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素大于实际存储的数据以便于添加新的元素。两者都允许直接按照序号索引元素。但是添加的元素涉及数组元素的移动操作，所有查找快而添加修改元素慢。Vector 中的方法由于添加了 syncheonized 修饰，所以 Vector 是线程安全的容器。LinkedList 使用双向链表实现存储。按照序号索引数据需要向前或者向后遍历。查找慢，但是添加元素快。</p>
<h2 id="启动一个线程是调用run还是start方法"><a class="markdownIt-Anchor" href="#启动一个线程是调用run还是start方法">#</a> 启动一个线程是调用 run () 还是 start () 方法？</h2>
<p>start ()：使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行，这并不意味着线程就会立即运行。run () 方法是线程启动后要进行回调的方法。</p>
<h2 id="线程池thread-pool"><a class="markdownIt-Anchor" href="#线程池thread-pool">#</a> 线程池（thread pool)</h2>
<p>在面向对象编程中，创建和销毁对象是比较耗费资源的，因为创建一个对象需要获取内存资源或者其它更多资源。在 Java 虚拟机中，虚拟机会试图跟踪每一个对象，以便后期对其资源的回收，所以想要提高服务的程序效率，有个办法就是尽可能的减少创建和销毁对象的次数。</p>
<p>所以对于一些很耗资源的对象创建和销毁，使用线程池技术可以较好的管理资源。首先创建诺干个可以执行的线程放在一个池中，需要的时候就从池中获取线程，而不用自行创建。使用完不必销毁而是放回池中，这样就减少了很大一部分创建和销毁的操作。从而减少资源开销。</p>
<p><strong>这里还有多种线程池可以了解一下。</strong></p>
<p>另外还有线程组的概念，但是不推荐使用，都是用线程池。</p>
<h2 id="java如何实现序列化意义是什么"><a class="markdownIt-Anchor" href="#java如何实现序列化意义是什么">#</a> Java 如何实现序列化，意义是什么？</h2>
<p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。</p>
<p><strong>意义： 解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题</strong></p>
<p>要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，标注该类对象可以被序列化，然后使用一个输出流来构造一个对象输出流并通</p>
<p>过 writeObject (Object) 方法就可以将实现对象写出（即保存其状态）；如果需要</p>
<p>反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中</p>
<p>读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆</p>
<h2 id="xml文档定义有几种形式它们之间有何本质区别解析xml文档有哪几种方式"><a class="markdownIt-Anchor" href="#xml文档定义有几种形式它们之间有何本质区别解析xml文档有哪几种方式">#</a> XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？</h2>
<p>XML 文档定义有两种形式，分别是 DTD 和 XSD。</p>
<p>DTD（Document Type Definition）是一种用于定义 XML 文档中元素、属性、实体和文档类型声明的语法规范。DTD 是一种早期的 XML 标准，其语法简单，但不够强大和灵活。</p>
<p>XSD（XML Schema Definition）是一种比 DTD 更为强大和灵活的 XML 文档定义语言，它使用 XML 格式编写，可以定义复杂的数据类型、较为精细的约束条件和元素关系等，支持命名空间和继承等概念。</p>
<p>本质区别在于，DTD 只能定义元素、属性和实体等基本结构，对于元素的数据类型、约束条件和关系等定义比较简单，而 XSD 则可以对数据类型、复杂元素、简单元素和属性等进行更为详细的定义和限制，灵活性更强。</p>
<p>XML 文档解析方式有 DOM 解析和 SAX 解析。</p>
<p>DOM（Document Object Model）解析方式是将整个 XML 文档解析成一个树形结构，程序可以通过访问树的方式来访问和操作 XML 文档。</p>
<p>SAX（Simple API for XML）解析方式是一种基于事件驱动的解析器，在解析过程中逐行读取 XML 文档，只有在需要的情况下才触发相应的事件。SAX 解析方式相比 DOM 更为高效，适用于处理大型 XML 文档。</p>
<h2 id="xml的用处"><a class="markdownIt-Anchor" href="#xml的用处">#</a> XML 的用处</h2>
<p>XML 的主要两个作用是：数据交互，信息配置</p>
<p>在数据交互时，XML 将数据用标签组装起来，然后压缩打包加密后通过网络传送给接收者，现在该该功能已经几乎被 JSON 取而代之了。</p>
<p>信息配置：现在很多软件仍然使用 XML 来存储配置信息。</p>
<h2 id="dao模式"><a class="markdownIt-Anchor" href="#dao模式">#</a> DAO 模式</h2>
<p>Data Access Object 顾名思义是一个为数据库或其它持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。</p>
<p>在实际开发中，应该将所有对数据源的访问操作进行抽象化封装在一个公共的 API 中。</p>
<p>用程序设计语言思想来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。</p>
<p>在这个程序中。当需要和数据源进行交互的时候就直接使用该接口。并且编写一个单独的类来实现这个接口。逻辑上该类对应一个特定的数据存储。</p>
<p>DAO 模式包括两个模式，</p>
<ol>
<li>Data Accessor (数据访问器)</li>
<li>Data Object (数据对象)</li>
</ol>
<p>第一种解决数据的访问问题，第二种解决用对象封装数据</p>
<p>。</p>
<h2 id="事务的acid是指什么"><a class="markdownIt-Anchor" href="#事务的acid是指什么">#</a> 事务的 ACID 是指什么？</h2>
<ul>
<li>原子性（Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事物的失败</li>
<li>一致性（Consistent)：事务结束后系统状态是一致的</li>
<li>隔离性（Isolated)：并发执行的事务彼此无法看到对方的中间状态</li>
<li>持久性（Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。</li>
</ul>
<p>关于事务的补充：</p>
<p>首先需要知道的是：只有存在并发数据访问时才需要事务。当多个事务访问同一个数据时，可能会存在 5 类问题，包括 3 类数据读取问题（脏读、不可重复读和幻读）和 2 类数据更新问题</p>
<h2 id="java中的volatile数组"><a class="markdownIt-Anchor" href="#java中的volatile数组">#</a> Java 中的 volatile 数组</h2>
<p>在 Java 中，“volatile” 关键字可以用于修饰数组类型的变量，以确保数组的可见性和原子性。</p>
<p>具体来说，如果一个线程修改了一个 volatile 数组中的元素，那么其他线程能够立即看到这个修改。而且，JVM 会保证 volatile 操作的原子性。也就是说，当一个线程正在更新一个 volatile 数组时，其他线程不能同时读取或修改该数组，以避免数据竞争和不一致的状态。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileArrayExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateNums</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        nums[index] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们声明了一个 volatile 的 int 数组 nums，并提供了两个方法 updateNums 和 getNum，分别用于更新和获取数组中的元素。</p>
<p>需要注意的是，虽然 volatile 数组能够确保可见性和原子性，但是它并不能保证线程安全。如果多个线程同时访问同一个 volatile 数组，并且进行复合操作（例如递增、递减、判断等），仍然需要进行额外的同步机制或者使用线程安全的数据结构来保证正确性。</p>
<h2 id="volatile修饰符有什么应用场景"><a class="markdownIt-Anchor" href="#volatile修饰符有什么应用场景">#</a> volatile 修饰符有什么应用场景</h2>
<p>一种应用场景是使用 volatile 修饰 long 和 double 变量，</p>
<p>double 和 long 都是 64 位宽，因此对这两种类型的读是分为两个部分的，第一次读取 32 位，然后再读取剩下的 32 位。这个过程不是原子的。</p>
<p>volatile 修饰符的另一个作用是提供内存屏障（memory barrier), 例如再分布式框架中的应用，简单来说：就是当你写一个 volatile 变量之前，java 内存模型会插入一个写屏障（write barrier), 读取该 volatile 变量之前，会插入一个读屏障（read barrier). 就是保证再修改一个 volatile 域时，要保证任何线程都能看到你修改的值，与此同时，在写之前，也要能保证任何数值的更新对所有线程都是可见的，因为内存屏障会将其它所有写的值更新到缓存。</p>
<h2 id="java中操作符是线程安全的吗"><a class="markdownIt-Anchor" href="#java中操作符是线程安全的吗">#</a> Java 中 ++ 操作符是线程安全的吗？</h2>
<p>不是线程安全的操作，它涉及到多个指令，如果读取变量值，后增加，然后存储回内存，这个过程可能会出现多个线程交差。</p>
<h2 id="int-和integer哪个会占用更多的内存"><a class="markdownIt-Anchor" href="#int-和integer哪个会占用更多的内存">#</a> int 和 Integer 哪个会占用更多的内存？</h2>
<p>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。</p>
<h1 id="spring"><a class="markdownIt-Anchor" href="#spring">#</a> Spring</h1>
<h2 id="spring的组件"><a class="markdownIt-Anchor" href="#spring的组件">#</a> Spring 的组件</h2>
<ul>
<li>接口：用来定义功能</li>
<li>Bean 类：用来赋予属性，提供 setter 和 getter 方法，以及一些函数</li>
<li>Spring 面向切面编程</li>
<li>Bean 配置文件</li>
<li>用户程序：暴露给使用者的接口</li>
</ul>
<h2 id="区分构造函数注入和setter注入"><a class="markdownIt-Anchor" href="#区分构造函数注入和setter注入">#</a> 区分构造函数注入和 setter 注入</h2>
<h1 id="springboot"><a class="markdownIt-Anchor" href="#springboot">#</a> SpringBoot</h1>
<h2 id="简单描述一下yaml是什么"><a class="markdownIt-Anchor" href="#简单描述一下yaml是什么">#</a> 简单描述一下 yaml 是什么</h2>
<p>它是一种可读的数据序列化语言，一般用作配置文件，yaml 更加结构化，使用分层配置数据</p>
<h2 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念">#</a> 基础概念</h2>
<ol>
<li>SpringBoot 是一个快速开发框架，简化了 XML 配置，提供了自动配置和开箱即用的功能，使得开发人员能够快速搭建应用程序。</li>
<li>SpringBoot 的核心原理是自动配置，通过继承 Spring 父类来实现大量的自动配置，从而简化了 XML 配置。</li>
<li>SpringBoot 的配置文件支持多种类型，包括.properties、.yml 和.yaml 文件，用于配置应用程序的各个方面。</li>
<li>SpringBoot 内置了 Tomcat 等服务器，使得无需额外配置即可运行 Web 应用程序。</li>
<li>SpringBoot 提供了对各种常用开发工具的整合，如 SpringMVC、SpringData、MyBatis 等，以及一些大型项目常用的非功能性特性的支持，如安全性、指标、健康检查等。</li>
<li>SpringBoot 的启动类上有一个关键的注解 @SpringBootApplication，它是 SpringBootApplication 类的子类，用于启动 SpringBoot 应用程序。</li>
<li>SpringBoot 的自动配置原理是通过在应用程序的类路径中搜索并加载符合条件的 Bean 定义，然后根据这些定义自动创建 Bean。</li>
<li>SpringBoot 对外部属性的支持是通过使用 SpringApplication.setDefaultProperties 来设置的，这使得我们可以在运行时传入额外的属性。</li>
<li>SpringBoot 的命令行参数可以通过使用 SpringApplication.run (Class&lt;?&gt;[] args) 方法来接收。</li>
<li>SpringBoot 的 Actuator 是用于监控和管理的模块，提供了对健康检查、指标收集等功能的支持。</li>
</ol>
<h1 id="redis"><a class="markdownIt-Anchor" href="#redis">#</a> Redis</h1>
<h2 id="redis优势"><a class="markdownIt-Anchor" href="#redis优势">#</a> Redis 优势</h2>
<p>性能极高 -----Redis 读写速度高</p>
<p>五种数据类型</p>
<p>1、 String (字符串)</p>
<p>2、 hash (哈希)</p>
<p>3、 list (列表)</p>
<p>4、 set (集合)</p>
<p>5、 Zset/sorted set (有序集合)</p>
<h2 id="redis持久化机制"><a class="markdownIt-Anchor" href="#redis持久化机制">#</a> Redis 持久化机制</h2>
<h2 id="一个redis实例最多能存放多少个keys"><a class="markdownIt-Anchor" href="#一个redis实例最多能存放多少个keys">#</a> 一个 redis 实例最多能存放多少个 keys？</h2>
<p>理论上可以有 232 个 keys, 实际使用取决于你的系统可用内存值。</p>
<h2 id="mysql中有2000w数据redis中只存了20w的数据如何保证redis中的数据都是热点数据"><a class="markdownIt-Anchor" href="#mysql中有2000w数据redis中只存了20w的数据如何保证redis中的数据都是热点数据">#</a> MySQL 中有 2000w 数据，redis 中只存了 20w 的数据，如何保证 redis 中的数据都是热点数据？</h2>
<p>Redis 内存数据集大小越来越多，当达到一定大小的时候，就会施行数据淘汰机制。</p>
<p>有 6 种数据淘汰机制：</p>
<p>volatile-lru：从已经设置过期时间的数据集中挑选出最近最少使用的数据淘汰掉</p>
<p>volatile-ttl：从已经设置过期时间的数据集中挑选将要过期的数据淘汰</p>
<p>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰</p>
<p>allkeys-random：从数据集中任选数据淘汰</p>
<p>no-enviction：禁止驱逐数据</p>
<h2 id="redis适合的应用场景"><a class="markdownIt-Anchor" href="#redis适合的应用场景">#</a> Redis 适合的应用场景</h2>
<p>1、 会话缓存（Session Cache)</p>
<p>Redis 提供持久化</p>
<p>2、 全页缓存（FPC)</p>
<p>除去基本的会话 Token 之外，使用 FPC 可以保证读写的高效性，同时降低磁盘 I/O 的读写压力，同时如果重启 redis, 由于有磁盘的持久化，可以保证快速的恢复内存中的数据</p>
<p>3、 队列</p>
<p>Redis 在内存存储引擎领域二点一大优点是提供 list 和 set 操作，这两大优点可以保证 Redis 能够作为一个很好的消息队列平台来使用.</p>
<p>4、 排行榜 / 计数器</p>
<p>Redis 在内存中对数字进行递增或递减的操作实现的非常好，Redis 提供得两大集合（Set) 和有序集合（Sorted Set) 也使得我们在执行这些操作变得非常简单。</p>
<h2 id="如果有大量的key需要设置同一时间过期一般需要注意什么"><a class="markdownIt-Anchor" href="#如果有大量的key需要设置同一时间过期一般需要注意什么">#</a> 如果有大量的 Key 需要设置同一时间过期，一般需要注意什么？</h2>
<p>如果有大量的 key 过期时间设置的过于集中，那么就会出现一到那个时间点就出现短暂的卡顿现象。所以一般需要在时间上加上一个随机值，使得过期时间分散一些，避免过于集中。</p>
<h1 id="springcloud"><a class="markdownIt-Anchor" href="#springcloud">#</a> SpringCloud</h1>
<h2 id="springcloud的优势"><a class="markdownIt-Anchor" href="#springcloud的优势">#</a> SpringCloud 的优势</h2>
<p>使用 SpringBoot 开发分布式微服务时，会有以下几个问题：</p>
<p>1、 与分布式系统相关的复杂性 - 这种开销包括网络问题，延迟开销，带宽问题，SpringBoot 并没有一个很好的解决方案去处理这样一个分布式的系统问题</p>
<p>2、 服务发现 - 作为一个工具，它管理着集中的流程和服务用来查找与服务之间的相互通信。</p>
<p>3、 性能 - 问题：各种微服务的开销比较大，不便于统一的进行管理</p>
<p>4、 部署的复杂性：使用 SpringCloud 可以更好的使用 Devops 的进行部署</p>
<p>5、 负载平衡：计算机集群，网络链接，中央处理器，磁盘驱动。</p>
<h2 id="spring-cloud-config"><a class="markdownIt-Anchor" href="#spring-cloud-config">#</a> Spring Cloud Config</h2>
<h1 id="rabbitmq"><a class="markdownIt-Anchor" href="#rabbitmq">#</a> RabbitMQ</h1>
<h2 id="简单描述一下"><a class="markdownIt-Anchor" href="#简单描述一下">#</a> 简单描述一下：</h2>
<p>RabbitMQ 是一个开放源代码的消息代理软件。</p>
<p>它是一个具有可靠的消息传递、发布 / 订阅功能以及消息持久性和排序等功能。RabbitMQ 的架构包括消息队列、生产者和消费者等组件。通过其可扩展的集群和故障转移功能，RabbitMQ 可以处理大量的消息并确保消息的可靠传输。</p>
<h2 id="消息基于什么传输"><a class="markdownIt-Anchor" href="#消息基于什么传输">#</a> 消息基于什么传输？</h2>
<p>由于 TCP 连接 的创 建和 销毁 开销 较大 ，且 并发 数受 系统 资源 限制 ，会 造成 性能 瓶</p>
<p>颈。 RabbitMQ 使用 信道 的方 式来 传输 数据 。 信 道是 建立 在真 实的 TCP 连接 内的</p>
<p>虚拟 连接 ，且 每条 TCP 连接 上的 信道 数量 没有 限制。</p>
<h1 id="java集合"><a class="markdownIt-Anchor" href="#java集合">#</a> Java 集合</h1>
<h2 id="讲讲你对集合的了解"><a class="markdownIt-Anchor" href="#讲讲你对集合的了解">#</a> 讲讲你对集合的了解</h2>
<p>首先，总共有这几大类集合：List、Set、Queue、Map。</p>
<p>主要特点：List 存储的数据有序，可重复</p>
<pre><code>	Set存储的数据不可重复

	Queue有序，可重复

	Map中的Key无序、不可重复，value无序、可重复
</code></pre>
<p>有个 Collection 接口</p>
<p>上面的 List，Set，Queue 都继承与它</p>
<h3 id="list"><a class="markdownIt-Anchor" href="#list">#</a> List</h3>
<p>主要有三个实现类：</p>
<p>ArrayList：最常用的实现类，内部通过数组实现，查询效率较高，插入和删除效率较低</p>
<p>Vector：通过数组实现，同时它与 ArrayList 的一个差别就是 Vector 支持线程同步，简单来说就是某一个时刻只有一个线程可以读写 Vector, 这样避免了多线程同时写找出数据的不一致。当然代价就是丢失性能。对于安全性能要求比较高，数据量较大且需要进行多线程访问的场景，它并不适合。</p>
<p>注：Vector 实现线程同步机制的方法是通过 synchronized 关键字。它会在所有的公共方法上加上 synchronized 关键字。</p>
<p>LinkedList：通过链表结构实现。插入和删除操作快，查找效率低</p>
<h3 id="set"><a class="markdownIt-Anchor" href="#set">#</a> Set</h3>
<p>主要有三个实现类：</p>
<p>HashSet：基于哈希表实现的集合，不允许重复元素。允许使用 null 元素，存储顺序和取出的顺序是一样的。线程不安全的集合。它适合用于存储大量的数据，并且对数据的存储顺序没有严格要求的场景，对数据的插入、删除、查找效率都比较高。</p>
<p>LinkedHashSet：不允许元素重复，允许 null 值，非线程安全，LinkedHashSet 是基于链表和哈希表实现的，当需要存储的数据量比较少，且需要按照插入的顺序遍历时。可以使用 LinkedHashSet</p>
<p>TreeSet：底层是红黑树（平衡二叉树）。不允许使用 null 元素，线程不安全。</p>
<p>注：以上三者都不允许重复元素，如果尝试重复元素，会抛出 IllegalStateException 或者 IIlegalArgumentException 异常</p>
<h3 id="queue"><a class="markdownIt-Anchor" href="#queue">#</a> Queue</h3>
<p>一种队列数据结构，</p>
<p>PriorityQueue：是一种基于优先级的队列，可以根据元素优先级来进行排序，优先级最高的元素总是位于队列的头部，而优先级最低的元素则位于队列的尾部。</p>
<p>ArrayQueue：是基于数组实现的，适用于需要频繁入队和出队操作的情况。</p>
<h3 id="map"><a class="markdownIt-Anchor" href="#map">#</a> Map</h3>
<p>HashMap：数组 + 链表。链表是为了解决哈希冲突而存在的。插入、查询、删除的效率高。</p>
<p>TreeMap：按照特定的顺序进行排序。</p>
<p>LinkedHashMap：能够保持其插入顺序。</p>
<p>Hashtable：不支持 null 的键或值。</p>
<p>ConcurrentHashMap：支持多线程并发访问，很高的写入性能，与 HashTable 相比，它支持 null 的键和值，并且具有更高的查询性能。</p>
<p>如何选用集合？</p>
<p>1、 数据的存储和访问方式，如果需要快速的查询和更新数据，可以选择 HashMap、TreeMap 或 LinkedHashMap，如果需要保证数据的顺序，可以选择 TreeMap 或 LinkedHashMap; 如果需要线程安全的数据操作，可以选择 ConcurrentHashMap.</p>
<p>2、 数据的大小，如果预计集合中的元素数量较小，可以选择 ArrayList 或 LinkedList，如果预计集合中的元素数量比较大，可以选择 HashSet 或 LinkedHashSet。</p>
<p>3、 是否需要排序，如果需要按照某种顺序排列集合中的元素，就选择 TreeSet 或者 LinkedHashSet.</p>
<p>4、 是否需要保存元素的插入顺序，如果需要，可以选择 LinkedHashSet 或者 LinkedHashMap.</p>
<p>5、 内存的占用和性能。需要高效使用内存的话，选择较小的数据结构，比如 ArrayList 和 HashSet.</p>
<h3 id="arraylist和array的区别"><a class="markdownIt-Anchor" href="#arraylist和array的区别">#</a> ArrayList 和 Array 的区别</h3>
<p>ArrayList 内部基于动态数组，而 Array 是静态数组</p>
<p>区别：</p>
<ul>
<li>
<p>ArrayLIst 会根据实际存储的元素动态的扩容或者缩容，而静态数组 Array 一经创建就没办法改变它的长度了。</p>
</li>
<li>
<p>ArrayList 允许你使用泛型保证类型的安全，但 Array 不可以。</p>
</li>
<li>
<p>ArrayList 只能存储对象，对于基本数据类型，需要使用对应的包装类（Integer、Double 等)</p>
<p>而 Array 可以直接存储基本类型，也可以存储对象</p>
</li>
<li>
<p>ArrayList 支持插入、删除、遍历等常见操作，提供丰富的 API 操作，而 Array 只是固定长度的数组。</p>
</li>
<li>
<p>ArrayList 创建时不需要指定大小，而 Array 创建时必须要指定大小</p>
</li>
</ul>
<h3 id="arraylist插入和删除元素的时间复杂度"><a class="markdownIt-Anchor" href="#arraylist插入和删除元素的时间复杂度">#</a> ArrayList 插入和删除元素的时间复杂度？</h3>
<p>三种情况插入和删除：</p>
<ul>
<li>头部插入删除：需要所有的元素依次向后或向前移动一个位置，时间复杂度为 O (n)</li>
<li>尾部插入删除：当 ArrayList 容量还没有达到极限时，插入时间复杂度为 O (1), 当达到极限时，就需要扩容操作，执行扩容操作的需要先执行 O（n) 操作将原数组复制到新的更大的数组中，然后在执行 O (1) 操作添加元素</li>
<li>指定位置插入删除：平均需要移动 n/2 个元素，时间复杂度为 O (n)</li>
</ul>
<h2 id="hashtable和hashmap的使用场景集合"><a class="markdownIt-Anchor" href="#hashtable和hashmap的使用场景集合">#</a> HashTable 和 HashMap 的使用场景集合：</h2>
<p>HashTable 和 HashMap 在 Java 开发过程中都用于存储键值对数据。区别主要在于线程安全与是否运行键值对为 null</p>
<p>首先是 HasdTable，它是线程安全的，常用于多线程环境下，由于多了一个线程安全，所以它的性能是要低于 HashMap 的。</p>
<p>另外关于键值对，它不支持或者说不允许使用 null 作为键和值。当你使用 null 时，它会抛出 NullPointerException.</p>
<p>其次，HashTable 提供了一组方法用来支持枚举遍历，这是与 HashMap 不同的一点</p>
<p>最后，在需要线程安全的情况下，你可以使用 HashTable，比如在多线程访问共享数据时</p>
<p>HashMap: 线程不安全，在单线程环境下适用，且性能更高。</p>
<p>允许 null 作为键和值。null 元素会计入 size 大小</p>
<h2 id="hashtable用什么来保证线程安全"><a class="markdownIt-Anchor" href="#hashtable用什么来保证线程安全">#</a> Hashtable 用什么来保证线程安全？</h2>
<p>在 Java 中，Hashtable 的实现使用 synchronized 关键字来保证线程安全。当多个线程同时访问 HashTable 时，Java 内置的一套锁机制会用来确保同一时间只有一个线程可以执行 HashTable 的某个个方法。</p>
<p>具体一点来讲，HashTable 中的每个方法（如 put,get，remove 等) 都会被 synchronized 关键字修饰，这意味着在执行这些方法时，都只有一个线程可以进入该方法。</p>
<p>注：随着现代大型 webApp 的发展，出现越来越多的高并发场景。而面对这样的高并发场景，HashTable 已经被视为一种过时的数据结构，现在更多的是使用 ConcurrentHashMap 等并发数据结构来替代 HashTable。</p>
<h2 id="解释一下hashtablestring-integer-hashtable-new-hashtable分别代表什么"><a class="markdownIt-Anchor" href="#解释一下hashtablestring-integer-hashtable-new-hashtable分别代表什么">#</a> 解释一下”Hashtable&lt;String, Integer&gt; hashtable = new Hashtable&lt;&gt;();“分别代表什么？</h2>
<p>该语句是用来创建并初始化 HashTable 对象的语句</p>
<ul>
<li>Hashtable&lt;String,Integer&gt;：这是声明一个 HashTable 类型的变量，其中 String 是键的类型，Integer 是值的类型。意味着你的 HashTable 中的 key 必须是 String 类型，values 必须是 Integer 类型。</li>
<li>hashtable：这是变量名</li>
<li>new Hashtable&lt;&gt;()：这部分是创建一个新的 Hashtable 实例。new 关键字在 Java 中用于创建对象，Hashtable（）是 Hashtable 的构造函数，它创建了一个新的、初始化的 Hashtable.</li>
</ul>
<h2 id="copyonwritearraylist和copyonwritearrayset的区别"><a class="markdownIt-Anchor" href="#copyonwritearraylist和copyonwritearrayset的区别">#</a> CopyOnWriteArrayList 和 CopyOnWriteArraySet 的区别？</h2>
<p>一个是 List 接口，一个是 Set 接口，CopyOnWriteArrayList 适用于对数据的随机访问和读取操作频繁，修改比较少的场景。</p>
<p>CopyOnWriteArraySet 适用于对数据读取操作比较少，但需要频繁进行修改的情况。</p>
<p>前者 List 支持 contains、get、set 等操作，</p>
<p>后者 Set 不支持 contains、get、set 等操作</p>
<p>由此可以得出：</p>
<p>当需要一个可以高效支持读操作的线程安全的集合时，应该使用 CopyOnWriteArrayList。</p>
<p>但需要一个不允许重复元素的线程安全的集合时，应该使用 CopyOnWriteArraySet。</p>
<h2 id="集合使用注意事项"><a class="markdownIt-Anchor" href="#集合使用注意事项">#</a> 集合使用注意事项</h2>
<h3 id="集合判空"><a class="markdownIt-Anchor" href="#集合判空">#</a> 集合判空</h3>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://github.com/hacker-jun/666.github.io">🌶辣椒炒饭</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/hacker-jun/666.github.io/2023/09/05/%E7%A7%8B%E6%8B%9B%E5%98%8E%E5%98%8E%E4%B9%B1%E6%9D%80/">https://github.com/hacker-jun/666.github.io/2023/09/05/%E7%A7%8B%E6%8B%9B%E5%98%8E%E5%98%8E%E4%B9%B1%E6%9D%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">jun</a> 许可协议。转载请注明来自 <a href="https://github.com/hacker-jun/666.github.io" target="_blank">Jun</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/666.github.io/img/f4aa9cd4d88b8eda7d695ba4f1c6cbb0_1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/666.github.io/2023/07/13/%E8%BF%90%E7%BB%B4/" title="运维"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">运维</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/666.github.io/img/f4aa9cd4d88b8eda7d695ba4f1c6cbb0_1.jpg" onerror="this.onerror=null;this.src='/666.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">🌶辣椒炒饭</div><div class="author-info__description">放弃幻想，准备斗争</div></div><div class="card-info-data site-data is-center"><a href="/666.github.io/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/666.github.io/tags/"><div class="headline">标签</div><div class="length-num">30</div></a><a href="/666.github.io/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" href="https://github.com/hacker-jun"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/hacker-jun/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:3050039321@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E5%B9%B6%E5%8F%91%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8F%98%E9%87%8F%E5%90%8C%E6%AD%A5"><span class="toc-number">1.</span> <span class="toc-text"> Java 并发：如何保证线程之间的变量同步？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%B9%B6%E5%8F%91%E5%9C%A8java%E4%B8%AD%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%9C%AC%E5%9C%B0%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text"> Java 并发：在 Java 中守护线程和本地线程区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E9%80%9A%E7%9F%A5"><span class="toc-number">1.2.</span> <span class="toc-text"> Spring 通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text"> 微服务架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.4.</span> <span class="toc-text"> volatile 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-number">1.5.</span> <span class="toc-text"> synchronized 修饰变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">1.6.</span> <span class="toc-text"> 多线程的上下文切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%B8%ADwait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">1.7.</span> <span class="toc-text"> Java 中 wait 和 sleep 方法的不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E4%BB%80%E4%B9%88%E6%A1%86%E6%9E%B6%E5%BB%BA%E7%AB%8B%E7%9A%84"><span class="toc-number">1.8.</span> <span class="toc-text"> 线程池是什么框架建立的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E6%8B%A5%E6%9C%89%E9%94%81"><span class="toc-number">1.9.</span> <span class="toc-text"> 如何检测一个线程是否拥有锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E5%AF%B9%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E7%90%86%E8%A7%A3%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.10.</span> <span class="toc-text"> 你对线程优先级的理解是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">1.11.</span> <span class="toc-text"> 并发编程的三要素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.12.</span> <span class="toc-text"> 四种线程池的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.13.</span> <span class="toc-text"> 线程池的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.14.</span> <span class="toc-text"> synchronized 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">1.15.</span> <span class="toc-text"> volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cas"><span class="toc-number">1.16.</span> <span class="toc-text"> CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8Bb%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E7%BA%BF%E7%A8%8Ba%E4%BF%AE%E6%94%B9%E4%BA%86%E5%8F%98%E9%87%8F"><span class="toc-number">1.17.</span> <span class="toc-text"> 线程 B 怎么知道线程 A 修改了变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronizedmap%E5%92%8Cconcueeenthashmap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.18.</span> <span class="toc-text"> SynchronizedMap 和 ConcueeentHashMap 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E6%A3%80%E6%B5%8B%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E6%8B%A5%E6%9C%89%E9%94%81"><span class="toc-number">1.19.</span> <span class="toc-text"> 怎样检测一个线程是否拥有锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%BF%87%E5%A4%9A%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E5%BC%82%E5%B8%B8"><span class="toc-number">1.20.</span> <span class="toc-text"> Java 线程数过多会造成什么异常？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0"><span class="toc-number">1.21.</span> <span class="toc-text"> JVM 的启动参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mybatis-%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text"> Mybatis: #{} 和 ${} 的区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E6%98%8Epreparedstatement"><span class="toc-number">2.1.</span> <span class="toc-text"> 说明：PreparedStatement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="toc-number">2.2.</span> <span class="toc-text"> 锁的类别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#myisam%E5%92%8Cinnodb%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text"> MyISAM 和 InnoDB 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#char-%E5%92%8C-varchar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text"> char 和 varchar 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text"> 防止 SQL 注入的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sql%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text"> SQL 优化的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mybatis%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">2.7.</span> <span class="toc-text"> Mybatis 的优势</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#javase%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%A4%9A%E6%80%81"><span class="toc-number">3.</span> <span class="toc-text"> JavaSE，封装，继承，多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6publicprivateprotected%E4%B8%8D%E5%86%99default"><span class="toc-number">3.1.</span> <span class="toc-text"> 四个访问修饰符，public，private，protected, 不写（default）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%A0%88stack%E5%A0%86heap%E6%96%B9%E6%B3%95%E5%8C%BAmethod-area"><span class="toc-number">3.2.</span> <span class="toc-text"> 内存中的栈（stack), 堆（heap), 方法区（method area).</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8Cstring%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%AE%E5%BC%82"><span class="toc-number">3.3.</span> <span class="toc-text"> 数组和 String 的一些差异</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8constructor%E4%B8%8E%E9%87%8D%E5%86%99override"><span class="toc-number">3.4.</span> <span class="toc-text"> 构造器（constructor）与重写（override)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E5%80%BC%E7%9B%B8%E5%90%8C%E5%8D%B3xequalsy-true%E4%BD%86%E6%9C%89%E4%B8%8D%E5%90%8C%E7%9A%84hash-code-%E6%98%AF%E5%90%A6%E6%AD%A3%E7%A1%AE"><span class="toc-number">3.5.</span> <span class="toc-text"> 两个对象值相同，即（x.equals (y) &#x3D;&#x3D; true), 但有不同的 hash code。是否正确？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%B1%BB%E5%88%AB%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="toc-number">3.6.</span> <span class="toc-text"> 类加载器的类别与作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%8B%E9%9A%86"><span class="toc-number">3.7.</span> <span class="toc-text"> 实现对象的克隆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8Bjvm%E5%8F%82%E6%95%B0%E5%B9%B6%E4%BA%86%E8%A7%A3%E5%85%B6%E5%90%AB%E4%B9%89"><span class="toc-number">3.8.</span> <span class="toc-text"> 查看 JVM 参数并了解其含义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%9E%84%E9%80%A0%E5%99%A8%E7%88%B6%E7%B1%BB%E4%B8%8E%E5%AD%90%E7%B1%BB%E5%90%8C%E5%AD%98%E7%9A%84%E4%BB%A3%E7%A0%81%E9%A2%98"><span class="toc-number">3.9.</span> <span class="toc-text"> 关于静态成员变量，构造器，父类与子类同存的代码题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cdn%E6%98%AF%E5%95%A5"><span class="toc-number">3.10.</span> <span class="toc-text"> CDN 是啥？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-s-new-stringxyz%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.11.</span> <span class="toc-text"> String s &#x3D; new String (“xyz”); 创建了几个字符串对象？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E9%81%93%E7%B1%BB%E4%BC%BC%E7%9A%84%E9%A2%98%E9%97%AE%E6%B3%95%E4%B8%8D%E5%90%8C"><span class="toc-number">3.12.</span> <span class="toc-text"> 一道类似的题：问法不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%90%E8%BF%B0arraylist-vector-linkedlist-%E7%9A%84%E5%AD%98%E5%82%A8%E6%80%A7%E8%83%BD%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">3.13.</span> <span class="toc-text"> 阐述 ArrayList、Vector、LinkedList 的存储性能和特性。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%98%AF%E8%B0%83%E7%94%A8run%E8%BF%98%E6%98%AFstart%E6%96%B9%E6%B3%95"><span class="toc-number">3.14.</span> <span class="toc-text"> 启动一个线程是调用 run () 还是 start () 方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0thread-pool"><span class="toc-number">3.15.</span> <span class="toc-text"> 线程池（thread pool)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.16.</span> <span class="toc-text"> Java 如何实现序列化，意义是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xml%E6%96%87%E6%A1%A3%E5%AE%9A%E4%B9%89%E6%9C%89%E5%87%A0%E7%A7%8D%E5%BD%A2%E5%BC%8F%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB%E8%A7%A3%E6%9E%90xml%E6%96%87%E6%A1%A3%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.17.</span> <span class="toc-text"> XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xml%E7%9A%84%E7%94%A8%E5%A4%84"><span class="toc-number">3.18.</span> <span class="toc-text"> XML 的用处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dao%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.19.</span> <span class="toc-text"> DAO 模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84acid%E6%98%AF%E6%8C%87%E4%BB%80%E4%B9%88"><span class="toc-number">3.20.</span> <span class="toc-text"> 事务的 ACID 是指什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84volatile%E6%95%B0%E7%BB%84"><span class="toc-number">3.21.</span> <span class="toc-text"> Java 中的 volatile 数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E4%BB%80%E4%B9%88%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.22.</span> <span class="toc-text"> volatile 修饰符有什么应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%B8%AD%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="toc-number">3.23.</span> <span class="toc-text"> Java 中 ++ 操作符是线程安全的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#int-%E5%92%8Cinteger%E5%93%AA%E4%B8%AA%E4%BC%9A%E5%8D%A0%E7%94%A8%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-number">3.24.</span> <span class="toc-text"> int 和 Integer 哪个会占用更多的内存？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#spring"><span class="toc-number">4.</span> <span class="toc-text"> Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">4.1.</span> <span class="toc-text"> Spring 的组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B3%A8%E5%85%A5%E5%92%8Csetter%E6%B3%A8%E5%85%A5"><span class="toc-number">4.2.</span> <span class="toc-text"> 区分构造函数注入和 setter 注入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springboot"><span class="toc-number">5.</span> <span class="toc-text"> SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8Byaml%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.1.</span> <span class="toc-text"> 简单描述一下 yaml 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">5.2.</span> <span class="toc-text"> 基础概念</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#redis"><span class="toc-number">6.</span> <span class="toc-text"> Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E4%BC%98%E5%8A%BF"><span class="toc-number">6.1.</span> <span class="toc-text"> Redis 优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.</span> <span class="toc-text"> Redis 持久化机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AAredis%E5%AE%9E%E4%BE%8B%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E4%B8%AAkeys"><span class="toc-number">6.3.</span> <span class="toc-text"> 一个 redis 实例最多能存放多少个 keys？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E4%B8%AD%E6%9C%892000w%E6%95%B0%E6%8D%AEredis%E4%B8%AD%E5%8F%AA%E5%AD%98%E4%BA%8620w%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">6.4.</span> <span class="toc-text"> MySQL 中有 2000w 数据，redis 中只存了 20w 的数据，如何保证 redis 中的数据都是热点数据？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E9%80%82%E5%90%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.5.</span> <span class="toc-text"> Redis 适合的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84key%E9%9C%80%E8%A6%81%E8%AE%BE%E7%BD%AE%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E8%BF%87%E6%9C%9F%E4%B8%80%E8%88%AC%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88"><span class="toc-number">6.6.</span> <span class="toc-text"> 如果有大量的 Key 需要设置同一时间过期，一般需要注意什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#springcloud"><span class="toc-number">7.</span> <span class="toc-text"> SpringCloud</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#springcloud%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">7.1.</span> <span class="toc-text"> SpringCloud 的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-cloud-config"><span class="toc-number">7.2.</span> <span class="toc-text"> Spring Cloud Config</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#rabbitmq"><span class="toc-number">8.</span> <span class="toc-text"> RabbitMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B"><span class="toc-number">8.1.</span> <span class="toc-text"> 简单描述一下：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E4%BC%A0%E8%BE%93"><span class="toc-number">8.2.</span> <span class="toc-text"> 消息基于什么传输？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java%E9%9B%86%E5%90%88"><span class="toc-number">9.</span> <span class="toc-text"> Java 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E4%BD%A0%E5%AF%B9%E9%9B%86%E5%90%88%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">9.1.</span> <span class="toc-text"> 讲讲你对集合的了解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#list"><span class="toc-number">9.1.1.</span> <span class="toc-text"> List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set"><span class="toc-number">9.1.2.</span> <span class="toc-text"> Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue"><span class="toc-number">9.1.3.</span> <span class="toc-text"> Queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map"><span class="toc-number">9.1.4.</span> <span class="toc-text"> Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arraylist%E5%92%8Carray%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.1.5.</span> <span class="toc-text"> ArrayList 和 Array 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arraylist%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">9.1.6.</span> <span class="toc-text"> ArrayList 插入和删除元素的时间复杂度？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashtable%E5%92%8Chashmap%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E9%9B%86%E5%90%88"><span class="toc-number">9.2.</span> <span class="toc-text"> HashTable 和 HashMap 的使用场景集合：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashtable%E7%94%A8%E4%BB%80%E4%B9%88%E6%9D%A5%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">9.3.</span> <span class="toc-text"> Hashtable 用什么来保证线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8Bhashtablestring-integer-hashtable-new-hashtable%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88"><span class="toc-number">9.4.</span> <span class="toc-text"> 解释一下”Hashtable&lt;String, Integer&gt; hashtable &#x3D; new Hashtable&lt;&gt;();“分别代表什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearraylist%E5%92%8Ccopyonwritearrayset%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.5.</span> <span class="toc-text"> CopyOnWriteArrayList 和 CopyOnWriteArraySet 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">9.6.</span> <span class="toc-text"> 集合使用注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%88%A4%E7%A9%BA"><span class="toc-number">9.6.1.</span> <span class="toc-text"> 集合判空</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/666.github.io/2023/09/05/%E7%A7%8B%E6%8B%9B%E5%98%8E%E5%98%8E%E4%B9%B1%E6%9D%80/" title="秋招嘎嘎乱杀">秋招嘎嘎乱杀</a><time datetime="2023-09-05T12:24:19.000Z" title="发表于 2023-09-05 20:24:19">2023-09-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/666.github.io/2023/07/13/%E8%BF%90%E7%BB%B4/" title="运维">运维</a><time datetime="2023-07-13T12:24:32.000Z" title="发表于 2023-07-13 20:24:32">2023-07-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/666.github.io/2023/06/27/Dubbo/" title="Dubbo">Dubbo</a><time datetime="2023-06-26T16:06:55.000Z" title="发表于 2023-06-27 00:06:55">2023-06-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/666.github.io/2023/05/10/%E5%AE%89%E5%8D%93adb/" title="安卓adb">安卓adb</a><time datetime="2023-05-10T11:30:57.000Z" title="发表于 2023-05-10 19:30:57">2023-05-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/666.github.io/2023/05/05/%E5%B7%A5%E4%BD%9C%E5%89%8D%E4%BA%8C%E5%88%B7Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="工作前二刷Lambda表达式">工作前二刷Lambda表达式</a><time datetime="2023-05-05T08:53:33.000Z" title="发表于 2023-05-05 16:53:33">2023-05-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/666.github.io/img/wallhaven-28rvdg.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By 🌶辣椒炒饭</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">你好，这里是jun's world</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/666.github.io/js/utils.js"></script><script src="/666.github.io/js/main.js"></script><script src="/666.github.io/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8202199818" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true"> </div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="200" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>